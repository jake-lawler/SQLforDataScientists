[["index.html", "Notes on SQL for Data Scientists by Renée M. P. Teate Preface", " Notes on SQL for Data Scientists by Renée M. P. Teate Jake Lawler 2022-03-30 Preface These are my notes on SQL for Data Scientists by Renée M. P. Teate. Here are the sources I referred to to get MySQL up-and-running from within R Markdown: The answer from Harley here on connecting to MySQL. The reference page for RMariaDB. The information on including SQL in R Markdown from Yihui Xies R Markdown book. Heres an example of the code Im using to connect to the books example database, Ill hide this in the future chapters: # Setting up library(DBI) # Connect to the book&#39;s example MySQL database con &lt;- dbConnect(RMariaDB::MariaDB(), dbname = &quot;farmers_market&quot;, host = &quot;localhost&quot;, port = 3306, user = &quot;root&quot;, password = keyring::key_get(&quot;mysql&quot;, &quot;root&quot;)) # No limit on the number of records to be displayed knitr::opts_knit$set(sql.max.print = NA) Ive used the keyring package to store my database password. The password is initially set by running code like the following in the console: keyring::key_set_with_value(&quot;mysql&quot;, username = &quot;root&quot;, password = &quot;password123&quot;) And then running the following code will return the value password123: keyring::key_get(&quot;mysql&quot;, &quot;root&quot;) You can then run queries by using R Markdowns support for SQL code snippets: SELECT * FROM farmers_market.product Table 0.1: Displaying records 1 - 10 product_id product_name product_size product_category_id product_qty_type 1 Habanero Peppers - Organic medium 1 lbs 2 Jalapeno Peppers - Organic small 1 lbs 3 Poblano Peppers - Organic large 1 unit 4 Banana Peppers - Jar 8 oz 3 unit 5 Whole Wheat Bread 1.5 lbs 3 unit 6 Cut Zinnias Bouquet medium 5 unit 7 Apple Pie 10 3 unit 8 Cherry Pie 10 3 unit 9 Sweet Potatoes medium 1 lbs 10 Eggs 1 dozen 6 unit Then disconnecting the database at the end of each chapter: # Disconnecting the database dbDisconnect(con) "],["data_sources.html", "Chapter 1 Data Sources 1.1 Chapter Notes 1.2 Exercises", " Chapter 1 Data Sources 1.1 Chapter Notes The chapter introduces the basics of relational databases. The concepts include: One-to-many relationships between tables. E.g. for a doctors office database a patient will appear once in the Patients table but may appear many times in the Appointments table Entity-Relationship Diagrams (ERDs). E.g. Primary Keys - a column or collection of columns that serves to uniquely identify each row in a table. Foreign Key - when a tables primary key is referenced in another table. E.g. when Patient ID appears in the Appointments table. Many-to-many relationships. E.g. between a Books table and an Authors table. A junction or associative table - these are used to match up primary keys for many-to-many relationships to reduce the amount of redundant data stored. Heres a diagram to explain: Here a single asterisk picks out the primary key, a double asterisk means that column is a foreign key. A book with multiple authors will have multiple rows in the junction table, instead of multiple rows in the books table where a lot more data would have to be repeated. Database normalisation - structuring a database so as to minimise redundant data storage. Dimensional model - a way of structuring a database into fact and dimension tables. The chapter explains: So, for example, a transactional record of an item purchased at a retail store is a fact, containing the timestamp of the purchase, the store number, order number, customer number, and the amount paid. The store the purchase was made at is a dimension of the item purchase fact, and the associated store dimension table would contain additional information about the store, such as its name. You could then query both the fact and the dimension tables to get a summary of purchases by store. The chapter then has a nice section about some of the questions you may want to ask when first being introduced to a data source, before going on to describe the Farmers Market database that will be used over the rest of the book. Heres the ERD: 1.2 Exercises Ex. 1 Question What do you think will happen in the described Books and Authors database depicted in Figure 1.5 if an author changes their name? Which records might be added or updated, and what might be the effect on the results of future queries based on this data? Answer If we wanted to completely overwrite the authors previous name, nothing in the Books table would need to change. The Author ID wouldnt need to change, and so nothing in the junction table would need to change. Only the entry for Author Full Name in the Authors table would need to be altered. In this case database normalisation has made updating the author name straightforward. However I believe the question is getting at the case where an author writes a book under one name, and then changes their name before releasing a new book. We want to keep both names in this database, each associated with the respective books. This could be accomplished by adding a new Author ID and a new row in the Authors table. However this could mislead us for some future queries - e.g. if we wanted to ask the average number of books written by each author, our query might count this as two authors with (say) one book each instead of the same author with two books. We cant have the same Author ID attached to each of the two names - Author ID is our primary key. Perhaps there is some other way to represent in our database that these two names refer to the same person. Ex. 2 Question Think of something in your life that you could track using a database. What entities in this database might have one-to-many relationships with one another? Many-to-many? Answer If I were so inclined, I could keep track of data about my walks and turn this into a database. E.g. what species of birds I see - I think this would be a many-to-many relationship, on each walk I see multiple species of birds and I might see each species on multiple walks. An example of one-to-many might be weather. I.e. it might be rainy on multiple different walks but each walk will only have one type of weather. Although that last part probably does not reflect the reality of being outside in Scotland. "],["select.html", "Chapter 2 The SELECT Statement 2.1 Chapter Notes 2.2 Exercises", " Chapter 2 The SELECT Statement 2.1 Chapter Notes The next few chapters introduce basic SQL syntax. Heres a very simple example: SELECT * FROM farmers_market.product Table 2.1: Displaying records 1 - 5 product_id product_name product_size product_category_id product_qty_type 1 Habanero Peppers - Organic medium 1 lbs 2 Jalapeno Peppers - Organic small 1 lbs 3 Poblano Peppers - Organic large 1 unit 4 Banana Peppers - Jar 8 oz 3 unit 5 Whole Wheat Bread 1.5 lbs 3 unit Weve selected all columns from the table named product, and Ive used R Markdowns knit options to limit the results displayed to the first five rows. We can use SQLs LIMIT clause for the same effect: SELECT * FROM farmers_market.product LIMIT 5 Table 2.2: 5 records product_id product_name product_size product_category_id product_qty_type 1 Habanero Peppers - Organic medium 1 lbs 2 Jalapeno Peppers - Organic small 1 lbs 3 Poblano Peppers - Organic large 1 unit 4 Banana Peppers - Jar 8 oz 3 unit 5 Whole Wheat Bread 1.5 lbs 3 unit Line breaks, tabs and spaces are treated the same by SQL. Usually adding line breaks makes for more legible code. Instead of asking for all columns, we can specify the ones we want in the SELECT clause: SELECT product_id, product_name FROM farmers_market.product LIMIT 5 Table 2.3: 5 records product_id product_name 1 Habanero Peppers - Organic 2 Jalapeno Peppers - Organic 3 Poblano Peppers - Organic 4 Banana Peppers - Jar 5 Whole Wheat Bread The chapter introduces the ORDER BY clause: SELECT product_id, product_name FROM farmers_market.product ORDER BY product_name LIMIT 5 Table 0.1: 5 records product_id product_name 7 Apple Pie 13 Baby Salad Lettuce Mix 12 Baby Salad Lettuce Mix - Bag 4 Banana Peppers - Jar 17 Carrots The default ASC behaviour sorts text alphabetically and numbers from low to high, but we can also use the DESC behaviour: SELECT product_id, product_name FROM farmers_market.product ORDER BY product_name DESC LIMIT 5 Table 2.4: 5 records product_id product_name 5 Whole Wheat Bread 9 Sweet Potatoes 16 Sweet Corn 22 Roma Tomatoes 15 Red Potatoes - Small We can also sort on multiple columns. The code below sorts first on market date and then on vendor ID: SELECT market_date, vendor_id, booth_number FROM farmers_market.vendor_booth_assignments ORDER BY market_date, vendor_id LIMIT 5 Table 2.5: 5 records market_date vendor_id booth_number 2019-04-03 1 2 2019-04-03 3 1 2019-04-03 4 7 2019-04-03 7 11 2019-04-03 8 6 We can also do simple calculations on the columns from within the SELECT clause. The code below contains two calculations like this. First, the columns quantity and cost_to_customer_per_qty are multiplied together. The the function ROUND is used to round the resulting price column to 2 digits after the decimal point. The ROUND function also accepts negative numbers to round digits to the left of the decimal point. The AS keyword is used to give the resulting column the alias price SELECT market_date, customer_id, vendor_id, ROUND(quantity * cost_to_customer_per_qty,2) AS price FROM farmers_market.customer_purchases LIMIT 5 Table 2.6: 5 records market_date customer_id vendor_id price 2019-07-03 14 7 6.92 2019-07-03 14 7 15.24 2019-07-03 15 7 10.69 2019-07-03 16 7 14.12 2019-07-03 22 7 4.61 Another common function is the CONCAT function, which can be used inside the SELECT statement to e.g. combine first and last names into a single column like so: CONCAT(customer_first_name,  , customer_last_name) AS customer_name. The UPPER function puts text values in all caps. There is then a section about using the query editor in MySQL workbench to perform some basic checks on your query. I did a little of that but obviously cant display that here. One option that R Markdown allows for though is to assign the result of your query to some R object using the output.var option. Here Ive included output.var=transactions in the SQL chunk options and when I run the query: SELECT market_date, customer_id, vendor_id, ROUND(quantity * cost_to_customer_per_qty, 2) AS price FROM farmers_market.customer_purchases I get a data frame with 4,221 rows, and I can then use standard R functions to check if the query is returning results as expected. E.g. range(transactions$market_date) ## [1] &quot;2019-04-03&quot; &quot;2020-10-10&quot; 2.2 Exercises Ex. 1 Question Write a query that returns everything in the customer table. Answer SELECT * FROM farmers_market.customer Table 2.7: 26 records customer_id customer_first_name customer_last_name customer_zip 1 Jane Connor 22801 2 Manuel Diaz 22821 3 Bob Wilson 22821 4 Deanna Washington 22801 5 Abigail Harris 22801 6 Betty Bullard 22801 7 Jessica Armenta 22821 8 Norma Valenzuela 22821 9 Janet Forbes 22801 10 Russell Edwards 22801 11 Richard Paulson 22801 12 Jack Wise 22821 13 Jeremy Gruber 22821 14 William Lopes 22801 15 Darrell Messina 22801 16 Ada Nieves 22801 17 Carlos Diaz 22802 18 Jeri Mitchell 22802 19 Iva Kienzler 22802 20 Valerie Loftis 22802 21 Duane Sipp 22801 22 George Rai 22801 23 Alvin Laurie 22801 24 Dawn Nale 22801 25 Bonnie Hassan 22801 26 Tracie Goehring 22821 Ex. 2 Question Write a query that displays all of the columns and 10 rows from the customer table, sorted by customer_last_name , then customer_first_name . Answer SELECT * FROM farmers_market.customer ORDER BY customer_last_name, customer_first_name LIMIT 10 Table 2.8: 10 records customer_id customer_first_name customer_last_name customer_zip 7 Jessica Armenta 22821 6 Betty Bullard 22801 1 Jane Connor 22801 17 Carlos Diaz 22802 2 Manuel Diaz 22821 10 Russell Edwards 22801 9 Janet Forbes 22801 26 Tracie Goehring 22821 13 Jeremy Gruber 22821 5 Abigail Harris 22801 Ex. 3 Question Write a query that lists all customer IDs and first names in the customer table, sorted by first_name. Answer SELECT customer_id, customer_first_name FROM farmers_market.customer ORDER BY customer_first_name Table 2.9: 26 records customer_id customer_first_name 5 Abigail 16 Ada 23 Alvin 6 Betty 3 Bob 25 Bonnie 17 Carlos 15 Darrell 24 Dawn 4 Deanna 21 Duane 22 George 19 Iva 12 Jack 1 Jane 9 Janet 13 Jeremy 18 Jeri 7 Jessica 2 Manuel 8 Norma 11 Richard 10 Russell 26 Tracie 20 Valerie 14 William "],["where.html", "Chapter 3 The WHERE Clause 3.1 Chapter Notes 3.2 Exercises", " Chapter 3 The WHERE Clause 3.1 Chapter Notes The chapter introduces the WHERE clause, which filters the results returned by your query. For example, the following code returns rows from the product table where the product_category_id is 1: SELECT product_id, product_name, product_category_id FROM farmers_market.product WHERE product_category_id = 1 LIMIT 5 Table 2.1: 5 records product_id product_name product_category_id 1 Habanero Peppers - Organic 1 2 Jalapeno Peppers - Organic 1 3 Poblano Peppers - Organic 1 9 Sweet Potatoes 1 12 Baby Salad Lettuce Mix - Bag 1 We can use Boolean operators OR, AND, NOT, AND NOT, or OR NOT with the WHERE clause. For example: SELECT market_date, customer_id, vendor_id, product_id, quantity, quantity * cost_to_customer_per_qty AS price FROM farmers_market.customer_purchases WHERE customer_id = 3 OR customer_id = 4 ORDER BY market_date, customer_id, vendor_id, product_id LIMIT 5 Table 2.2: 5 records market_date customer_id vendor_id product_id quantity price 2019-04-03 3 7 4 1 4.0 2019-04-03 4 7 4 1 4.0 2019-04-06 4 8 5 1 6.5 2019-04-10 4 7 4 5 20.0 2019-04-10 4 7 4 3 12.0 We can also use &gt;, &lt;, &gt;=, &lt;=. SELECT market_date, customer_id, vendor_id, product_id, quantity, quantity * cost_to_customer_per_qty AS price FROM farmers_market.customer_purchases WHERE customer_id &gt; 2 AND customer_id &lt;= 4 ORDER BY market_date, customer_id, vendor_id, product_id LIMIT 5 Table 2.3: 5 records market_date customer_id vendor_id product_id quantity price 2019-04-03 3 7 4 1 4.0 2019-04-03 4 7 4 1 4.0 2019-04-06 4 8 5 1 6.5 2019-04-10 4 7 4 5 20.0 2019-04-10 4 7 4 3 12.0 And we can nest operators using parentheses: SELECT product_id, product_name FROM farmers_market.product WHERE product_id = 10 OR (product_id &gt; 3 AND product_id &lt; 8) Table 0.1: 5 records product_id product_name 4 Banana Peppers - Jar 5 Whole Wheat Bread 6 Cut Zinnias Bouquet 7 Apple Pie 10 Eggs We arent confined to filter on a single column, we could easily use the WHERE clause to return e.g. rows where the customer_id is &lt; 5 and the vendor_id is 8 or similar. Other options for filtering include BETWEEN: SELECT * FROM farmers_market.vendor_booth_assignments WHERE vendor_id = 7 AND market_date BETWEEN &#39;2019-04-03&#39; AND &#39;2019-04-16&#39; ORDER BY market_date Table 2.4: 4 records vendor_id booth_number market_date 7 11 2019-04-03 7 11 2019-04-06 7 11 2019-04-10 7 11 2019-04-13 IN: SELECT customer_id, customer_first_name, customer_last_name FROM farmers_market.customer WHERE customer_last_name IN (&#39;Diaz&#39;, &#39;Edwards&#39;, &#39;Wilson&#39;) ORDER BY customer_last_name, customer_first_name Table 2.5: 4 records customer_id customer_first_name customer_last_name 17 Carlos Diaz 2 Manuel Diaz 10 Russell Edwards 3 Bob Wilson LIKE: SELECT customer_id, customer_first_name, customer_last_name FROM farmers_market.customer WHERE customer_first_name LIKE &#39;Jer%&#39; Table 2.6: 2 records customer_id customer_first_name customer_last_name 13 Jeremy Gruber 18 Jeri Mitchell Here the % sign acts as a wildcard so that all first names that start with Jer and have any number (or zero) additional characters will be included. IS NULL / IS NOT NULL - this one is pretty straightforward but note that NULL entries and blank entries are not the same: SELECT * FROM farmers_market.product WHERE product_size IS NULL OR TRIM(product_size) = &#39;&#39; Table 3.1: 2 records product_id product_name product_size product_category_id product_qty_type 14 Red Potatoes NA 1 NA 15 Red Potatoes - Small 1 NA The TRIM function used above removes spaces from the beginning and end of a string, and so can be used to find rows with entries that are blank, or just a space, or any number of spaces. Each of these are different from a NULL entry. The chapter ends with a section on subqueries - queries within queries. In the IN example above, we used a hardcoded list of names, but we could also feed the results of one query into the WHERE criteria of another query: SELECT market_date, customer_id, vendor_id, quantity * cost_to_customer_per_qty price FROM farmers_market.customer_purchases WHERE market_date IN ( SELECT market_date FROM farmers_market.market_date_info WHERE market_rain_flag = 1 ) LIMIT 5 Table 3.2: 5 records market_date customer_id vendor_id price 2019-07-31 3 7 18.4536 2019-07-31 8 7 26.7717 2019-07-31 19 7 25.7931 2019-07-31 22 7 7.4793 2019-09-21 6 7 13.9101 In the query above we use a query on the market_date_info table to return all the dates when it rained, and then query the customer_purchases table to return purchases on those days. 3.2 Exercises Ex. 1 Question Refer to the data in Table 3.1. Write a query that returns all customer purchases of product IDs 4 and 9. Answer Heres Table 3.1: SELECt * FROM table3.1 WHERE PRODUCT_ID = 4 OR PRODUCT_ID = 9 Ex. 2 Question Refer to the data in Table 3.1. Write two queries, one using two conditions with an AND operator, and one using the BETWEEN operator, that will return all customer purchases made from vendors with vendor IDs between 8 and 10 (inclusive). Answer SELECt * FROM table3.1 WHERE VENDOR_ID &gt;= 8 AND VENDOR_ID &lt;= 10 SELECt * FROM table3.1 WHERE VENDOR_ID BETWEEN 8 AND 10 Ex. 3 Question Can you think of two different ways to change the final query in the chapter so it would return purchases from days when it wasnt raining? Answer We could change the criterion on market_rain_flag to 0: SELECT market_date, customer_id, vendor_id, quantity * cost_to_customer_per_qty price FROM farmers_market.customer_purchases WHERE market_date IN ( SELECT market_date FROM farmers_market.market_date_info WHERE market_rain_flag = 0 ) LIMIT 5 Table 3.3: 5 records market_date customer_id vendor_id price 2019-07-03 14 7 6.9201 2019-07-03 14 7 15.2382 2019-07-03 15 7 10.6947 2019-07-03 16 7 14.1198 2019-07-03 22 7 4.6134 Or we could use NOT IN instead of IN: SELECT market_date, customer_id, vendor_id, quantity * cost_to_customer_per_qty price FROM farmers_market.customer_purchases WHERE market_date NOT IN ( SELECT market_date FROM farmers_market.market_date_info WHERE market_rain_flag = 1 ) LIMIT 5 Table 3.4: 5 records market_date customer_id vendor_id price 2019-07-03 14 7 6.9201 2019-07-03 14 7 15.2382 2019-07-03 15 7 10.6947 2019-07-03 16 7 14.1198 2019-07-03 22 7 4.6134 "],["case.html", "Chapter 4 CASE Statements 4.1 Chapter Notes 4.2 Exercises", " Chapter 4 CASE Statements 4.1 Chapter Notes CASE statements are used to create derived columns. Heres a list of vendors and the kind of items they sell: SELECT vendor_id, vendor_name, vendor_type FROM farmers_market.vendor Table 2.1: 9 records vendor_id vendor_name vendor_type 1 Chriss Sustainable Eggs &amp; Meats Eggs &amp; Meats 2 Hernández Salsa &amp; Veggies Fresh Variety: Veggies &amp; More 3 Mountain View Vegetables Fresh Variety: Veggies &amp; More 4 Fields of Corn Fresh Focused 5 Seashell Clay Shop Arts &amp; Jewelry 6 Mothers Garlic &amp; Greens Fresh Variety: Veggies &amp; More 7 Marcos Peppers Fresh Focused 8 Annies Pies Prepared Foods 9 Mediterranean Bakery Prepared Foods We can use a CASE statement to add a new column that specifies whether the vendors sell fresh produce or something else: SELECT vendor_id, vendor_name, vendor_type, CASE WHEN LOWER(vendor_type) LIKE &#39;%fresh%&#39; THEN &#39;Fresh Produce&#39; ELSE &#39;Other&#39; END AS vendor_type_condensed FROM farmers_market.vendor Table 2.2: 9 records vendor_id vendor_name vendor_type vendor_type_condensed 1 Chriss Sustainable Eggs &amp; Meats Eggs &amp; Meats Other 2 Hernández Salsa &amp; Veggies Fresh Variety: Veggies &amp; More Fresh Produce 3 Mountain View Vegetables Fresh Variety: Veggies &amp; More Fresh Produce 4 Fields of Corn Fresh Focused Fresh Produce 5 Seashell Clay Shop Arts &amp; Jewelry Other 6 Mothers Garlic &amp; Greens Fresh Variety: Veggies &amp; More Fresh Produce 7 Marcos Peppers Fresh Focused Fresh Produce 8 Annies Pies Prepared Foods Other 9 Mediterranean Bakery Prepared Foods Other Note the comma after vendor_type - it looks like CASE is included as part of the SELECT clause. Note also the catch-all ELSE command. CASE statements are often used to create binary flag fields: SELECT market_date, CASE WHEN market_day = &#39;Saturday&#39; OR market_day = &#39;Sunday&#39; THEN 1 ELSE 0 END AS weekend_flag FROM farmers_market.market_date_info LIMIT 5 Table 2.3: 5 records market_date weekend_flag 2019-03-02 1 2019-03-09 1 2019-03-13 0 2019-03-16 1 2019-03-20 0 or to bin continuous variables: SELECT market_date, customer_id, vendor_id, ROUND(quantity * cost_to_customer_per_qty, 2) AS price, CASE WHEN quantity * cost_to_customer_per_qty &lt; 5.00 THEN &#39;Under $5&#39; WHEN quantity * cost_to_customer_per_qty &lt; 10.00 THEN &#39;$5-$9.99&#39; WHEN quantity * cost_to_customer_per_qty &lt; 20.00 THEN &#39;$10-$19.99&#39; WHEN quantity * cost_to_customer_per_qty&gt;= 20.00 THEN &#39;$20 and Up&#39; END AS price_bin FROM farmers_market.customer_purchases LIMIT 10 Table 0.1: 10 records market_date customer_id vendor_id price price_bin 2019-07-03 14 7 6.92 $5-$9.99 2019-07-03 14 7 15.24 $10-$19.99 2019-07-03 15 7 10.69 $10-$19.99 2019-07-03 16 7 14.12 $10-$19.99 2019-07-03 22 7 4.61 Under $5 2019-07-06 4 7 1.89 Under $5 2019-07-06 12 7 25.16 $20 and Up 2019-07-06 14 7 21.25 $20 and Up 2019-07-06 23 7 10.42 $10-$19.99 2019-07-06 23 7 17.89 $10-$19.99 4.2 Exercises Ex. 1 Question Products can be sold by the individual unit or by bulk measures like lbs. or oz. Write a query that outputs the product_id and product_name columns from the product table, and add a column called prod_qty_type_condensed that displays the word unit if the product_qty_type is unit, and otherwise displays the word bulk. Answer SELECT product_id, product_name, CASE WHEN LOWER(product_qty_type) LIKE &#39;%unit%&#39; THEN &#39;unit&#39; ELSE &#39;bulk&#39; END AS prod_qty_type_condensed FROM farmers_market.product Table 2.4: 23 records product_id product_name prod_qty_type_condensed 1 Habanero Peppers - Organic bulk 2 Jalapeno Peppers - Organic bulk 3 Poblano Peppers - Organic unit 4 Banana Peppers - Jar unit 5 Whole Wheat Bread unit 6 Cut Zinnias Bouquet unit 7 Apple Pie unit 8 Cherry Pie unit 9 Sweet Potatoes bulk 10 Eggs unit 11 Pork Chops bulk 12 Baby Salad Lettuce Mix - Bag unit 13 Baby Salad Lettuce Mix bulk 14 Red Potatoes bulk 15 Red Potatoes - Small bulk 16 Sweet Corn unit 17 Carrots bulk 18 Carrots - Organic unit 19 Farmers Market Resuable Shopping Bag unit 20 Homemade Beeswax Candles unit 21 Organic Cherry Tomatoes unit 22 Roma Tomatoes bulk 23 Maple Syrup - Jar unit Ex. 2 Question We want to flag all of the different types of pepper products that are sold at the market. Add a column to the previous query called pepper_flag that outputs a 1 if the product_name contains the word pepper (regardless of capitalization), and otherwise outputs 0. Answer SELECT product_id, product_name, CASE WHEN LOWER(product_qty_type) LIKE &#39;%unit%&#39; THEN &#39;unit&#39; ELSE &#39;bulk&#39; END AS prod_qty_type_condensed, CASE WHEN LOWER(product_name) LIKE &#39;%pepper%&#39; THEN 1 ELSE 0 END AS pepper_flag FROM farmers_market.product Table 2.5: 23 records product_id product_name prod_qty_type_condensed pepper_flag 1 Habanero Peppers - Organic bulk 1 2 Jalapeno Peppers - Organic bulk 1 3 Poblano Peppers - Organic unit 1 4 Banana Peppers - Jar unit 1 5 Whole Wheat Bread unit 0 6 Cut Zinnias Bouquet unit 0 7 Apple Pie unit 0 8 Cherry Pie unit 0 9 Sweet Potatoes bulk 0 10 Eggs unit 0 11 Pork Chops bulk 0 12 Baby Salad Lettuce Mix - Bag unit 0 13 Baby Salad Lettuce Mix bulk 0 14 Red Potatoes bulk 0 15 Red Potatoes - Small bulk 0 16 Sweet Corn unit 0 17 Carrots bulk 0 18 Carrots - Organic unit 0 19 Farmers Market Resuable Shopping Bag unit 0 20 Homemade Beeswax Candles unit 0 21 Organic Cherry Tomatoes unit 0 22 Roma Tomatoes bulk 0 23 Maple Syrup - Jar unit 0 Ex. 3 Question Can you think of a situation when a pepper product might not get flagged as a pepper product using the code from the previous exercise? Answer The product could just be called Jalapenos - Organic or similar, anything without the word pepper in it wont be flagged. "],["sql_joins.html", "Chapter 5 SQL JOINs 5.1 Chapter Notes 5.2 Exercises", " Chapter 5 SQL JOINs 5.1 Chapter Notes JOINs are used to pull data from across multiple related tables. Lets say we want to list the name of each product along with its category. These are stored in different tables: SELECT * FROM product LEFT JOIN product_category ON product.product_category_id = product_category.product_category_id LIMIT 5 Table 2.1: 5 records product_id product_name product_size product_category_id product_qty_type product_category_id..6 product_category_name 1 Habanero Peppers - Organic medium 1 lbs 1 Fresh Fruits &amp; Vegetables 2 Jalapeno Peppers - Organic small 1 lbs 1 Fresh Fruits &amp; Vegetables 3 Poblano Peppers - Organic large 1 unit 1 Fresh Fruits &amp; Vegetables 4 Banana Peppers - Jar 8 oz 3 unit 3 Packaged Prepared Food 5 Whole Wheat Bread 1.5 lbs 3 unit 3 Packaged Prepared Food The code above stitches together the product table and the product_category table, used the product_category_id column in each. This is a LEFT JOIN, which means: All rows in the product table are kept, even if there are no matches in the product_category table Rows in the product_category table for IDs that dont appear in the product table are dropped. If there are no products in the product table with product_category_id 7 (Non-Edible Products), then that row of the product_category table will not appear in the results. Also, the code above is the first time Ive seen the code not specify the database. I.e. it refers to product instead of farmers_market.product. Im not exactly sure about when this can be left out, but its not specific to JOINs at all - the farmers_market part can be removed from the queries in previous chapters and the code will still run. Note that product_category_id appears in the results above twice - one from each table (although I believe R is adding ..6 to the second one, since it doesnt like data frames with multiple columns with the same name). We could prevent this by specifying which columns to include, or by creating an alias for the column names that specifies which table each ID column came from: SELECT product.product_id, product.product_name, product.product_category_id AS product_prod_cat_id, product_category.product_category_id AS category_prod_cat_id, product_category.product_category_name FROM product LEFT JOIN product_category ON product.product_category_id = product_category.product_category_id LIMIT 5 Table 2.2: 5 records product_id product_name product_prod_cat_id category_prod_cat_id product_category_name 1 Habanero Peppers - Organic 1 1 Fresh Fruits &amp; Vegetables 2 Jalapeno Peppers - Organic 1 1 Fresh Fruits &amp; Vegetables 3 Poblano Peppers - Organic 1 1 Fresh Fruits &amp; Vegetables 4 Banana Peppers - Jar 3 3 Packaged Prepared Food 5 Whole Wheat Bread 3 3 Packaged Prepared Food The chapter also demonstrates aliasing that is used to shorten the table names in the rest of the query for convenience. It doesnt affect results. In the code that follows the product table is aliased as p and the product_category table is aliased as pc. SELECT p.product_id, p.product_name, pc.product_category_id, pc.product_category_name FROM product AS p LEFT JOIN product_category AS pc ON p.product_category_id = pc.product_category_id ORDER BY pc.product_category_name, p.product_name LIMIT 5 Table 2.3: 5 records product_id product_name product_category_id product_category_name 10 Eggs 6 Eggs &amp; Meat (Fresh or Frozen) 11 Pork Chops 6 Eggs &amp; Meat (Fresh or Frozen) 13 Baby Salad Lettuce Mix 1 Fresh Fruits &amp; Vegetables 12 Baby Salad Lettuce Mix - Bag 1 Fresh Fruits &amp; Vegetables 17 Carrots 1 Fresh Fruits &amp; Vegetables You can see the shortened table names used in the SELECT clause, and when specifying the joining columns and ordering. In general with aliasing, the AS keyword is optional. The code product AS p and product p will do the same thing. RIGHT JOINs work analogously: SELECT p.product_id, p.product_name, pc.product_category_id, pc.product_category_name FROM product AS p RIGHT JOIN product_category AS pc ON p.product_category_id = pc.product_category_id ORDER BY p.product_name LIMIT 5 Table 0.1: 5 records product_id product_name product_category_id product_category_name NA NA 4 Freshly Prepared Food 7 Apple Pie 3 Packaged Prepared Food 13 Baby Salad Lettuce Mix 1 Fresh Fruits &amp; Vegetables 12 Baby Salad Lettuce Mix - Bag 1 Fresh Fruits &amp; Vegetables 4 Banana Peppers - Jar 3 Packaged Prepared Food A couple points to note about these results. All rows from the product_category table are included, even when no product is assigned to that category. In the table above, no products are in category 4 (Freshly Prepared Food), but it still appears in the results. Rows from the product_category table can be included multiple times. The results above (when not using LIMIT) will have 24 rows, one for each of the 23 products plus 1 for category 4. If there could be multiple product categories for each product, then they would both appear in the left join performed above, so the results would have more than 23 rows. INNER JOINs keep only rows where the product_category_id appears in both tables: SELECT p.product_id, p.product_name, pc.product_category_id, pc.product_category_name FROM product AS p INNER JOIN product_category AS pc ON p.product_category_id = pc.product_category_id ORDER BY p.product_name LIMIT 5 Table 2.4: 5 records product_id product_name product_category_id product_category_name 7 Apple Pie 3 Packaged Prepared Food 13 Baby Salad Lettuce Mix 1 Fresh Fruits &amp; Vegetables 12 Baby Salad Lettuce Mix - Bag 1 Fresh Fruits &amp; Vegetables 4 Banana Peppers - Jar 3 Packaged Prepared Food 17 Carrots 1 Fresh Fruits &amp; Vegetables In this case the results are the same as the left join, since each product has an assigned product_category_id. Joins can be performed multiple times, with the second join effectively acting to join together the results of the first join with another table. 5.2 Exercises Ex. 1 Question Write a query that INNER JOINs the vendor table to the vendor_booth_assignments table on the vendor_id field they both have in common, and sorts the result by vendor_name , then market_date. Answer SELECT * FROM vendor AS v INNER JOIN vendor_booth_assignments AS vba ON v.vendor_id = vba.vendor_id ORDER BY vendor_name, market_date LIMIT 5 Table 2.5: 5 records vendor_id vendor_name vendor_type vendor_owner_first_name vendor_owner_last_name vendor_id..6 booth_number market_date 8 Annies Pies Prepared Foods Annie Aquinas 8 6 2019-04-03 8 Annies Pies Prepared Foods Annie Aquinas 8 6 2019-04-06 8 Annies Pies Prepared Foods Annie Aquinas 8 6 2019-04-10 8 Annies Pies Prepared Foods Annie Aquinas 8 6 2019-04-13 8 Annies Pies Prepared Foods Annie Aquinas 8 6 2019-04-17 Ex. 2 Question Is it possible to write a query that produces an output identical to the output of the following query, but using a LEFT JOIN instead of a RIGHT JOIN? SELECT * FROM customer AS c RIGHT JOIN customer_purchases AS cp ON c.customer_id = cp.customer_id LIMIT 10 Table 2.6: 10 records customer_id customer_first_name customer_last_name customer_zip product_id vendor_id market_date customer_id..8 quantity cost_to_customer_per_qty transaction_time 14 William Lopes 22801 1 7 2019-07-03 14 0.99 6.99 17:32:00 14 William Lopes 22801 1 7 2019-07-03 14 2.18 6.99 18:23:00 15 Darrell Messina 22801 1 7 2019-07-03 15 1.53 6.99 18:41:00 16 Ada Nieves 22801 1 7 2019-07-03 16 2.02 6.99 18:18:00 22 George Rai 22801 1 7 2019-07-03 22 0.66 6.99 17:34:00 4 Deanna Washington 22801 1 7 2019-07-06 4 0.27 6.99 12:20:00 12 Jack Wise 22821 1 7 2019-07-06 12 3.60 6.99 09:33:00 14 William Lopes 22801 1 7 2019-07-06 14 3.04 6.99 13:05:00 23 Alvin Laurie 22801 1 7 2019-07-06 23 1.49 6.99 12:26:00 23 Alvin Laurie 22801 1 7 2019-07-06 23 2.56 6.99 12:46:00 Answer Probably theres a less clumsy way of getting the columns in the right order, but this works: SELECT c.customer_id, c.customer_first_name, c.customer_last_name, c.customer_zip, cp.product_id, cp.vendor_id, cp.market_date, cp.customer_id, cp.quantity, cp.cost_to_customer_per_qty, cp.transaction_time FROM customer_purchases AS cp LEFT JOIN customer AS c ON cp.customer_id = c.customer_id LIMIT 10 Table 3.1: 10 records customer_id customer_first_name customer_last_name customer_zip product_id vendor_id market_date customer_id..8 quantity cost_to_customer_per_qty transaction_time 14 William Lopes 22801 1 7 2019-07-03 14 0.99 6.99 17:32:00 14 William Lopes 22801 1 7 2019-07-03 14 2.18 6.99 18:23:00 15 Darrell Messina 22801 1 7 2019-07-03 15 1.53 6.99 18:41:00 16 Ada Nieves 22801 1 7 2019-07-03 16 2.02 6.99 18:18:00 22 George Rai 22801 1 7 2019-07-03 22 0.66 6.99 17:34:00 4 Deanna Washington 22801 1 7 2019-07-06 4 0.27 6.99 12:20:00 12 Jack Wise 22821 1 7 2019-07-06 12 3.60 6.99 09:33:00 14 William Lopes 22801 1 7 2019-07-06 14 3.04 6.99 13:05:00 23 Alvin Laurie 22801 1 7 2019-07-06 23 1.49 6.99 12:26:00 23 Alvin Laurie 22801 1 7 2019-07-06 23 2.56 6.99 12:46:00 Ex. 3 Question At the beginning of this chapter, the analytical question When is each type of fresh fruit or vegetable in season, locally? was asked, and it was explained that the answer requires data from the product_category table, the product table, and the vendor_inventory table. What type of JOINs do you expect would be needed to combine these three tables in order to be able to answer this question? Answer I believe this code would get you most of the way there. You just need a way of summarising the range of market_date for each product, which it looks like we might learn in the next chapter. SELECT p.product_id, p.product_name, pc.product_category_name, vi.market_date FROM product AS p LEFT JOIN product_category AS pc ON p.product_category_id = pc.product_category_id LEFT JOIN vendor_inventory AS vi ON p.product_id = vi.product_id WHERE LOWER(product_category_name) LIKE &quot;%fruit%&quot; ORDER BY product_name, market_date LIMIT 10 Table 3.2: 10 records product_id product_name product_category_name market_date 13 Baby Salad Lettuce Mix Fresh Fruits &amp; Vegetables NA 12 Baby Salad Lettuce Mix - Bag Fresh Fruits &amp; Vegetables NA 17 Carrots Fresh Fruits &amp; Vegetables NA 18 Carrots - Organic Fresh Fruits &amp; Vegetables NA 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-03 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-06 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-10 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-13 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-17 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-20 Although we wont be able to get an answer if there is nothing recorded in the vendor_inventory table for that item, so perhaps wed be just as well using an INNER JOIN for that second join. However it may be useful to know when the information we want isnt available, rather than just silently dropping the NULL results. "],["aggregating.html", "Chapter 6 Aggregating Results for Analysis 6.1 Chapter Notes 6.2 Exercises", " Chapter 6 Aggregating Results for Analysis 6.1 Chapter Notes This chapter is all about aggregating and summarising data. It introduces the GROUP BY clause. This query returns the dates and customer IDs of all purchases: SELECT market_date, customer_id FROM farmers_market.customer_purchases ORDER BY market_date, customer_id LIMIT 5 Table 2.1: 5 records market_date customer_id 2019-04-03 3 2019-04-03 4 2019-04-03 5 2019-04-03 5 2019-04-03 6 We can see two purchases by customer 5 on 2019-04-03. We can use the GROUP BY clause to gather those two rows together, by grouping on market_date and customer_id. With no further changes to the query, this would do the same thing as SELECT DISTINCT. However with a summarising function, we can display more useful information: SELECT market_date, customer_id, COUNT(*) AS items_purchased FROM farmers_market.customer_purchases GROUP BY market_date, customer_id ORDER BY market_date, customer_id LIMIT 5 Table 2.2: 5 records market_date customer_id items_purchased 2019-04-03 3 1 2019-04-03 4 1 2019-04-03 5 2 2019-04-03 6 2 2019-04-03 7 1 Here the COUNT function counts the number of rows in each market_date and customer_id grouping, as displays that in a new column. We can now see more readily that customer 5 made two purchases on March 3rd. We can use other summarising functions. For example, for each purchase the table records the quantity of items purchased. We can create a column displaying that instead of the number of distinct purchases: SELECT market_date, customer_id, SUM(quantity) AS items_purchased FROM farmers_market.customer_purchases GROUP BY market_date, customer_id ORDER BY market_date, customer_id LIMIT 5 Table 2.3: 5 records market_date customer_id items_purchased 2019-04-03 3 1 2019-04-03 4 1 2019-04-03 5 4 2019-04-03 6 5 2019-04-03 7 5 So customer made 5 2 distinct purchases but bought 4 different items over those two purchases. The chapter recommends running a query like this without the summarising function first, in order to check that its doing what you think it is. In the query above, the quantity column for some products is recorded by weight instead of number of items, so the results may not be as expected. Similarly when aggregating on joins its a good idea to perform the join first and check that its working as expected before aggregating anything. We can also perform row-level calculations that are then aggregated by our summarising functions. For example, here is the query to return how much customer 3 spent at the market on each date: SELECT market_date, customer_id, SUM(quantity* cost_to_customer_per_qty) AS total_spent FROM customer_purchases WHERE customer_id = 3 GROUP BY market_date, customer_id ORDER BY market_date LIMIT 10 Table 0.1: 10 records market_date customer_id total_spent 2019-04-03 3 4.0 2019-04-13 3 56.0 2019-04-24 3 20.0 2019-04-27 3 72.0 2019-05-01 3 52.0 2019-05-08 3 12.0 2019-05-11 3 108.0 2019-05-15 3 24.5 2019-05-22 3 96.5 2019-05-29 3 19.5 Heres an example of aggregating on a join. We combine three tables (customer purchases, customer, vendor) to get the names of customers and how much they spent in total at each vendor over the entire time period we have data for. We then sort highest to lowest. SELECT cp.customer_id, c.customer_first_name, c.customer_last_name, vendor_name, SUM(quantity* cost_to_customer_per_qty) AS total_spent FROM customer_purchases AS cp LEFT JOIN customer AS c ON cp.customer_id = c.customer_id LEFT JOIN vendor AS v ON cp.vendor_id = v.vendor_id GROUP BY customer_id, vendor_name ORDER BY total_spent DESC LIMIT 5 Table 2.4: 5 records customer_id customer_first_name customer_last_name vendor_name total_spent 5 Abigail Harris Annies Pies 2728.0 3 Bob Wilson Annies Pies 2722.0 2 Manuel Diaz Annies Pies 2650.5 8 Norma Valenzuela Annies Pies 2646.0 24 Dawn Nale Annies Pies 2634.0 There is more than one vendor in the results of that query, its just that people appear to be spending a large amount of money on Annies Pies. Other possible functions we might want to use on grouped results include: MAX and MIN (e.g. to find the most expensive produce in each category), We saw COUNT above but we can also use COUNT DISTINCT when we want to count unique rows only. The syntax works like so: COUNT(DISTINCT product_id), AVG, for the average The next section of the chapter introduces the HAVING clause, which is used for filtering after aggregation. It goes after the GROUP BY clause. The following query returns the total amount each customer spent at each vendor, and then filters for total amount over $1,000. SELECT customer_id, vendor_name, SUM(quantity * cost_to_customer_per_qty) AS total_spent FROM customer_purchases AS cp JOIN vendor AS v ON cp.vendor_id = v.vendor_id GROUP BY customer_id, vendor_name HAVING total_spent &gt;= 1000 ORDER BY customer_id, vendor_name LIMIT 10 Table 2.5: 10 records customer_id vendor_name total_spent 1 Annies Pies 2311.000 1 Marcos Peppers 1131.219 2 Annies Pies 2650.500 2 Marcos Peppers 1457.053 3 Annies Pies 2722.000 3 Marcos Peppers 1031.257 4 Annies Pies 2002.000 4 Marcos Peppers 1412.429 5 Annies Pies 2728.000 5 Marcos Peppers 1159.627 Heres a tip from the chapter: &gt; If you GROUP BY all of the fields that are supposed to be distinct in your resulting dataset, then add a HAVING clause that filters to aggregated rows with a COUNT(*) &gt; 1 , any results returned indicate that there is more than one row with your unique combination of values, highlighting the existence of unwanted duplicates in your database or query results! The next section discusses CASE statements inside aggregating functions. We learned above that the quantity column in the customer_purchases table is sometimes in lbs and sometimes in units (e.g. 1 tomato). We can use CASE statements so that only products with the same units are summed together. This query returns the total quantity of items purchased per customer per day, separated by units. Ive order it by quantity in lbs from highest to lowest. SELECT cp.market_date,cp.customer_id, SUM(CASE WHEN product_qty_type = &quot;unit&quot; THEN quantity ELSE 0 END) AS quantity_units, SUM(CASE WHEN product_qty_type = &quot;lbs&quot; THEN quantity ELSE 0 END) AS quantity_lbs FROM farmers_market.customer_purchases AS cp INNER JOIN farmers_market.product AS p ON cp.product_id = p.product_id GROUP BY market_date, customer_id ORDER BY quantity_lbs DESC LIMIT 5 Table 2.6: 5 records market_date customer_id quantity_units quantity_lbs 2020-09-19 15 8 11.98 2019-07-13 10 10 11.32 2020-07-11 18 0 11.10 2020-08-22 5 8 10.81 2019-07-13 2 12 10.51 So customer 15 bought almost 12 pounds of items on 2020-09-19, as well as 8 units of other products. Lets see what they were: SELECT market_date, customer_id, product_name, quantity, product_qty_type FROM customer_purchases AS cp LEFT JOIN product AS p ON cp.product_id = p.product_id WHERE customer_id = 15 AND market_date = &quot;2020-09-19&quot; Table 3.1: 5 records market_date customer_id product_name quantity product_qty_type 2020-09-19 15 Habanero Peppers - Organic 3.04 lbs 2020-09-19 15 Habanero Peppers - Organic 5.06 lbs 2020-09-19 15 Jalapeno Peppers - Organic 3.88 lbs 2020-09-19 15 Poblano Peppers - Organic 3.00 unit 2020-09-19 15 Banana Peppers - Jar 5.00 unit Damn. A pepper fiend. 6.2 Exercises Ex. 1 Question Write a query that determines how many times each vendor has rented a booth at the farmers market. In other words, count the vendor booth assignments per vendor_id . Answer SELECT vendor_id, COUNT(booth_number) AS total_assignments FROM vendor_booth_assignments GROUP BY vendor_id ORDER BY vendor_id Table 3.2: 6 records vendor_id total_assignments 1 142 3 142 4 211 7 142 8 142 9 142 Ex. 2 Question In Chapter 5, SQL Joins, Exercise 3, we asked When is each type of fresh fruit or vegetable in season, locally? Write a query that displays the product category name, product name, earliest date available, and latest date available for every product in the Fresh Fruits &amp; Vegetables product category. Answer Adapting my answer from exercise three of the last chapter: SELECT p.product_name, pc.product_category_name, MIN(vi.market_date) AS earliest_date_available, MAX(vi.market_date) AS latest_date_available FROM product AS p LEFT JOIN product_category AS pc ON p.product_category_id = pc.product_category_id LEFT JOIN vendor_inventory AS vi ON p.product_id = vi.product_id WHERE LOWER(product_category_name) LIKE &quot;%fruit%&quot; AND market_date IS NOT NULL GROUP BY product_name ORDER BY product_name, market_date Table 2.7: 4 records product_name product_category_name earliest_date_available latest_date_available Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-03 2020-09-30 Jalapeno Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-03 2020-09-30 Poblano Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-03 2020-09-30 Sweet Corn Fresh Fruits &amp; Vegetables 2019-06-01 2020-09-30 I dont like that they all have the same end date, but a quick check reveals that the data does go further than that, just not for products in the Fresh Fruits category. SELECT MIN(market_date) AS start_date, MAX(market_date) AS end_date FROM vendor_inventory Table 2.8: 1 records start_date end_date 2019-04-03 2020-10-10 I also dont like how the latest_date_available is more than one year after the earliest_date_available. The question is about seasonality, and so the earliest and latest dates should be within a year of each other. To fix this, well need date functions, which are introduced in chapter 8. Ex. 3 Question The Farmers Market Customer Appreciation Committee wants to give a bumper sticker to everyone who has ever spent more than $50 at the market. Write a query that generates a list of customers for them to give stickers to, sorted by last name, then first name. Answer The question is slightly ambiguous. Does this mean $50 total or $50 in one transaction? Heres the query for total amount, it looks like every customer in the database has spent well over $1,000: SELECT c.customer_last_name, c.customer_first_name, SUM(quantity* cost_to_customer_per_qty) AS total_spent FROM customer_purchases AS cp LEFT JOIN customer AS c ON cp.customer_id = c.customer_id GROUP BY customer_last_name, customer_first_name HAVING total_spent &gt; 50 ORDER BY customer_last_name, customer_first_name LIMIT 5 Table 2.9: 5 records customer_last_name customer_first_name total_spent Armenta Jessica 2921.174 Bullard Betty 3016.465 Connor Jane 3530.919 Diaz Carlos 1882.612 Diaz Manuel 4179.453 Heres the query if were looking for at least $50 in one transaction: SELECT customer_last_name, customer_first_name, MAX(quantity*cost_to_customer_per_qty) AS most_spent FROM customer_purchases AS cp JOIN customer AS c ON cp.customer_id = c.customer_id GROUP BY customer_last_name, customer_first_name HAVING most_spent &gt; 50 ORDER BY customer_last_name, customer_first_name LIMIT 5 Table 3.3: 5 records customer_last_name customer_first_name most_spent Armenta Jessica 54 Bullard Betty 54 Connor Jane 54 Diaz Carlos 54 Diaz Manuel 54 Concerned about the frequency of $54 dollars but after checking it does look like the query ran successfully. "],["window_functions.html", "Chapter 7 Window Functions and Subqueries 7.1 Chapter Notes 7.2 Exercises", " Chapter 7 Window Functions and Subqueries 7.1 Chapter Notes Like aggregates, windows functions can operate across multiple rows. However the records dont have to be grouped in the output. They can return group-level information alongside each row. As an example, heres the aggregation weve seen before: SELECT vendor_id, MAX(original_price) AS highest_price FROM vendor_inventory GROUP BY vendor_id ORDER BY vendor_id Table 2.1: 3 records vendor_id highest_price 4 0.50 7 6.99 8 18.00 By contrast, using window functions we can see the price of each product and compare it against the highest price directly. SELECT DISTINCT vendor_id, product_id, original_price, MAX(original_price) OVER (PARTITION BY vendor_id) AS highest_price FROM vendor_inventory ORDER BY vendor_id, product_id Table 2.2: 8 records vendor_id product_id original_price highest_price 4 16 0.50 0.50 7 1 6.99 6.99 7 2 3.49 6.99 7 3 0.50 6.99 7 4 4.00 6.99 8 5 6.50 18.00 8 7 18.00 18.00 8 8 18.00 18.00 The first window functions introduced are ranking functions. The following code ranks each vendors products by price from high to low. Each vendors highest price product is given a 1, their second highest price gets a 2, and so on. SELECT vendor_id, market_date, product_id, original_price, ROW_NUMBER() OVER (PARTITION BY vendor_id ORDER BY original_price DESC) AS price_rank FROM vendor_inventory ORDER BY price_rank, vendor_id LIMIT 10 Table 2.3: 10 records vendor_id market_date product_id original_price price_rank 4 2019-06-01 16 0.50 1 7 2019-07-03 1 6.99 1 8 2019-04-03 7 18.00 1 4 2019-06-05 16 0.50 2 7 2019-07-06 1 6.99 2 8 2019-04-06 7 18.00 2 4 2019-06-08 16 0.50 3 7 2019-07-10 1 6.99 3 8 2019-04-10 7 18.00 3 4 2019-06-12 16 0.50 4 ROW_NUMBER increments up the count even if two rows have the same value. I.e. you can see in the above table that vendor_id 4 has multiple products priced at $0.50, but one gets rank 1 and the others get rank 2,3 and so on. The chapter introduces subqueries. We can use them to find the most expensive product from each vendor. This is a subquery, it treats the results of the inner query as a table, and then queries that table. SELECT * FROM( SELECT vendor_id, market_date, product_id, original_price, ROW_NUMBER() OVER (PARTITION BY vendor_id ORDER BY original_price DESC) AS price_rank FROM vendor_inventory ORDER BY vendor_id ) AS x WHERE x.price_rank = 1 Table 0.1: 3 records vendor_id market_date product_id original_price price_rank 4 2019-06-01 16 0.50 1 7 2019-07-03 1 6.99 1 8 2019-04-03 7 18.00 1 The chapter explains why we cant just use the WHERE clause: The reason we have to structure this as a subquery is that the entire dataset has to be processed in order for the window function to find the highest price per vendor. So we cant filter the results using a WHERE clause (which youll remember evaluates the conditional statements row by row) because when that filtering is applied, the ROW_NUMBER has not yet been calculated for every row. The window functions RANK and DENSE RANK have the same syntax as ROW_NUMBER, but do different things. RANK works like ROW_NUMBER, but gives rows with the same value the same ranking. If there is a tie for second among two rows, for example, both rows would get the value 2, and there would be no row assigned value 3. The next value assigned would be 4. DENSE RANK does the same but doesnt skip over rankings after a tie. I.e. a value may be assigned a 3 even if there are more than 2 rows ahead of it. The function NTILE assigns quantiles. The following code breaks items into ten groups based on original_price, assigning a 1 to the highest priced tenth. We can use subqueries to filter on the price_ntile row, in this case returning the top tenth only. SELECT * FROM( SELECT vendor_id, market_date, product_id, original_price, NTILE(10) OVER (ORDER BY original_price DESC) AS price_ntile FROM vendor_inventory ORDER BY original_price DESC ) AS x WHERE x.price_ntile = 1 LIMIT 5 Table 2.4: 5 records vendor_id market_date product_id original_price price_ntile 8 2019-04-03 7 18 1 8 2019-04-06 7 18 1 8 2019-04-10 7 18 1 8 2019-04-13 7 18 1 8 2019-04-17 7 18 1 NTILE works on row counts, not on values specified in the ORDER BY clause, so two rows with the same original_price could end up in different buckets. We can also use the aggregate functions weve already seen as window functions. E.g. if we want to compare each rows value to the average value of that group. Here we calculate the average price of products on each date: SELECT vendor_id, market_date, product_id, original_price, AVG(original_price) OVER (PARTITION BY market_date) AS average_cost_product_by_market_date FROM vendor_inventory LIMIT 5 Table 2.5: 5 records vendor_id market_date product_id original_price average_cost_product_by_market_date 7 2019-04-03 4 4.0 11.625 8 2019-04-03 5 6.5 11.625 8 2019-04-03 7 18.0 11.625 8 2019-04-03 8 18.0 11.625 7 2019-04-06 4 4.0 11.625 We can use a simiar query to quickly see how many products each vendor brought on each date, without aggregating: SELECT vendor_id, market_date, product_id, original_price, COUNT(product_id) OVER (PARTITION BY vendor_id, market_date) AS vendor_products_per_date FROM vendor_inventory ORDER BY vendor_id DESC, market_date LIMIT 10 Table 2.6: 10 records vendor_id market_date product_id original_price vendor_products_per_date 8 2019-04-03 5 6.5 3 8 2019-04-03 7 18.0 3 8 2019-04-03 8 18.0 3 8 2019-04-06 5 6.5 3 8 2019-04-06 7 18.0 3 8 2019-04-06 8 18.0 3 8 2019-04-10 5 6.5 3 8 2019-04-10 7 18.0 3 8 2019-04-10 8 18.0 3 8 2019-04-13 5 6.5 3 Another use for window functions is to calculate running totals. In the code below we dont partition by anything, but do use the ORDER BY clause inside the window query. However we could use a partition to get individual running totals for each customer, for example. SELECT customer_id, market_date, vendor_id, product_id, quantity * cost_to_customer_per_qty AS price, SUM(quantity * cost_to_customer_per_qty) OVER (ORDER BY market_date, transaction_time, customer_id, product_id) AS running_total_purchases FROM customer_purchases LIMIT 10 Table 3.1: 10 records customer_id market_date vendor_id product_id price running_total_purchases 9 2019-04-03 8 8 36.0 36.0 9 2019-04-03 8 7 18.0 54.0 9 2019-04-03 8 5 6.5 60.5 9 2019-04-03 8 7 36.0 96.5 6 2019-04-03 8 5 6.5 103.0 9 2019-04-03 8 5 6.5 109.5 23 2019-04-03 8 7 18.0 127.5 23 2019-04-03 8 7 36.0 163.5 23 2019-04-03 8 8 54.0 217.5 7 2019-04-03 7 4 20.0 237.5 The functions LAG and LEAD allow you to use values a specified number of steps before or after the current row. The code below returns the booth number most recently used by each vendor. SELECT market_date, vendor_id, booth_number, LAG(booth_number,1) OVER (PARTITION BY vendor_id ORDER BY market_date,vendor_id) AS previous_booth_number FROM farmers_market.vendor_booth_assignments ORDER BY market_date, vendor_id, booth_number LIMIT 10 Table 3.2: 10 records market_date vendor_id booth_number previous_booth_number 2019-04-03 1 2 NA 2019-04-03 3 1 NA 2019-04-03 4 7 NA 2019-04-03 7 11 NA 2019-04-03 8 6 NA 2019-04-03 9 8 NA 2019-04-06 1 2 2 2019-04-06 3 1 1 2019-04-06 4 7 7 2019-04-06 7 11 11 We can check when vendors change booths by wrapping the above query in another query: SELECT * FROM( SELECT market_date, vendor_id, booth_number, LAG(booth_number,1) OVER (PARTITION BY vendor_id ORDER BY market_date,vendor_id) AS previous_booth_number FROM farmers_market.vendor_booth_assignments ORDER BY market_date, vendor_id, booth_number ) AS x WHERE x.booth_number != x.previous_booth_number LIMIT 5 Table 2.7: 5 records market_date vendor_id booth_number previous_booth_number 2019-04-10 1 7 2 2019-04-10 4 2 7 2019-04-13 1 2 7 2019-04-13 4 7 2 2019-06-01 4 11 7 The next query combines aggregation and LAG, first calculating total sales on each date, and creating a column with the previous dates total sales. SELECT market_date, SUM(quantity * cost_to_customer_per_qty) AS market_date_total_sales, LAG(SUM(quantity * cost_to_customer_per_qty), 1) OVER (ORDER BY market_date) AS previous_market_date_total_sales FROM customer_purchases GROUP BY market_date ORDER BY market_date LIMIT 10 Table 2.8: 10 records market_date market_date_total_sales previous_market_date_total_sales 2019-04-03 475.0 NA 2019-04-06 549.5 475.0 2019-04-10 505.0 549.5 2019-04-13 377.0 505.0 2019-04-17 493.5 377.0 2019-04-20 455.5 493.5 2019-04-24 366.0 455.5 2019-04-27 444.5 366.0 2019-05-01 523.0 444.5 2019-05-04 497.0 523.0 LEAD works similarly, but fetches values from rows ahead. 7.2 Exercises Ex. 1 Question Do the following two steps: Write a query that selects from the customer_purchases table and numbers each customers visits to the farmers market (labeling each market date with a different number). Each customers first visit is labeled 1, second visit is labeled 2, etc. (We are of course not counting visits where no purchases are made, because we have no record of those.) You can either display all rows in the customer_purchases table, with the counter changing on each new market date for each customer, or select only the unique market dates per customer (without purchase details) and number those visits. HINT: One of these approaches uses ROW_NUMBER() and one uses DENSE_RANK() . Reverse the numbering of the query from a part so each customers most recent visit is labeled 1, then write another query that uses this one as a subquery and filters the results to only the customers most recent visit. Answer Some customers make more than one purchase on a certain date, and so using ROW_NUMBER will increment up multiple times in one day. We can use DENSE_RANK() and DISTINCT if we only want to increment up on distinct days. SELECT DISTINCT market_date, customer_id, DENSE_RANK() OVER (PARTITION BY customer_id ORDER BY market_date) AS customer_visit_num FROM customer_purchases ORDER BY customer_id, market_date LIMIT 5 Table 2.9: 5 records market_date customer_id customer_visit_num 2019-04-06 1 1 2019-04-13 1 2 2019-04-17 1 3 2019-04-20 1 4 2019-04-24 1 5 Part b: SELECT customer_id, market_date AS most_recent_visit FROM ( SELECT DISTINCT market_date, customer_id, DENSE_RANK() OVER (PARTITION BY customer_id ORDER BY market_date DESC) AS customer_visit_num FROM customer_purchases ) AS x WHERE x.customer_visit_num =1 LIMIT 10 Table 3.3: 10 records customer_id most_recent_visit 1 2020-10-10 2 2020-10-10 3 2020-10-07 4 2020-10-03 5 2020-10-10 6 2020-10-10 7 2020-10-10 8 2020-10-10 9 2020-10-10 10 2020-10-10 Ex. 2 Question Using a COUNT() window function, include a value along with each row of the customer_purchases table that indicates how many different times that customer has purchased that product_id. Answer SELECT DISTINCT customer_id, product_name, COUNT(*) OVER (PARTITION BY customer_id, cp.product_id) AS times_purchased FROM customer_purchases AS cp LEFT JOIN product AS p ON cp.product_id = p.product_id LIMIT 5 Table 3.4: 5 records customer_id product_name times_purchased 1 Habanero Peppers - Organic 9 1 Jalapeno Peppers - Organic 13 1 Poblano Peppers - Organic 29 1 Banana Peppers - Jar 64 1 Whole Wheat Bread 47 Ex. 3 Question In the last query associated with Figure 7.14 from the chapter, we used LAG and sorted by market_date. Can you think of a way to use LEAD in place of LAG , but get the exact same output? Answer Heres the image: I wont be able to get the same output because the database has changed since the book was published, but heres the query in the chapter. Ill try to recreate these results: SELECT market_date, SUM(quantity * cost_to_customer_per_qty) AS market_date_total_sales, LAG(SUM(quantity * cost_to_customer_per_qty), 1) OVER (ORDER BY market_date) AS previous_market_date_total_sales FROM farmers_market.customer_purchases GROUP BY market_date ORDER BY market_date LIMIT 10 Table 7.1: 10 records market_date market_date_total_sales previous_market_date_total_sales 2019-04-03 475.0 NA 2019-04-06 549.5 475.0 2019-04-10 505.0 549.5 2019-04-13 377.0 505.0 2019-04-17 493.5 377.0 2019-04-20 455.5 493.5 2019-04-24 366.0 455.5 2019-04-27 444.5 366.0 2019-05-01 523.0 444.5 2019-05-04 497.0 523.0 Heres my attempt, I changed the sorting order inside the window query. SELECT market_date, SUM(quantity * cost_to_customer_per_qty) AS market_date_total_sales, LEAD(SUM(quantity * cost_to_customer_per_qty), 1) OVER (ORDER BY market_date DESC) AS previous_market_date_total_sales FROM farmers_market.customer_purchases GROUP BY market_date ORDER BY market_date LIMIT 10 Table 7.2: 10 records market_date market_date_total_sales previous_market_date_total_sales 2019-04-03 475.0 NA 2019-04-06 549.5 475.0 2019-04-10 505.0 549.5 2019-04-13 377.0 505.0 2019-04-17 493.5 377.0 2019-04-20 455.5 493.5 2019-04-24 366.0 455.5 2019-04-27 444.5 366.0 2019-05-01 523.0 444.5 2019-05-04 497.0 523.0 "],["date_time.html", "Chapter 8 Date and Time Functions 8.1 Chapter Notes 8.2 Exercises Further Reading", " Chapter 8 Date and Time Functions 8.1 Chapter Notes 8.2 Exercises Ex. 1 Question Answer Further Reading "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
