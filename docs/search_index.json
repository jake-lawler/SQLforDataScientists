[["index.html", "Notes on SQL for Data Scientists by Renée M. P. Teate Preface", " Notes on SQL for Data Scientists by Renée M. P. Teate Jake Lawler 2022-03-08 Preface These are my notes on SQL for Data Scientists by Renée M. P. Teate. Ive only just started so theres not much here yet. Here are the sources I referred to to get MySQL up-and-running from within R Markdown: The answer from Harley here on connecting to MySQL. The reference page for RMariaDB. The information on including SQL in R Markdown from Yihui Xies R Markdown book. Heres an example of the code Im using to connect to the books example database, Ill hide this in the future chapters: # Setting up library(DBI) # Connect to the book&#39;s example MySQL database con &lt;- dbConnect(RMariaDB::MariaDB(), dbname = &quot;farmers_market&quot;, host = &quot;localhost&quot;, port = 3306, user = &quot;root&quot;, password = keyring::key_get(&quot;mysql&quot;, &quot;root&quot;)) # No limit on the number of records to be displayed knitr::opts_knit$set(sql.max.print = NA) You can then run queries by using R Markdowns support for SQL code snippets: SELECT * FROM farmers_market.product Table 0.1: Displaying records 1 - 10 product_id product_name product_size product_category_id product_qty_type 1 Habanero Peppers - Organic medium 1 lbs 2 Jalapeno Peppers - Organic small 1 lbs 3 Poblano Peppers - Organic large 1 unit 4 Banana Peppers - Jar 8 oz 3 unit 5 Whole Wheat Bread 1.5 lbs 3 unit 6 Cut Zinnias Bouquet medium 5 unit 7 Apple Pie 10 3 unit 8 Cherry Pie 10 3 unit 9 Sweet Potatoes medium 1 lbs 10 Eggs 1 dozen 6 unit Then disconnecting the database at the end of each chapter: # Disconnecting the database dbDisconnect(con) "],["data_sources.html", "Chapter 1 Data Sources 1.1 Chapter Notes 1.2 Exercises", " Chapter 1 Data Sources 1.1 Chapter Notes The chapter introduces the basics of relational databases. The concepts include: One-to-many relationships between tables. E.g. for a doctors office database a patient will appear once in the Patients table but may appear many times in the Appointments table Entity-Relationship Diagrams (ERDs). E.g. Primary Keys - a column or collection of columns that serves to uniquely identify each row in a table. Foreign Key - when a tables primary key is referenced in another table. E.g. when Patient ID appears in the Appointments table. Many-to-many relationships. E.g. between a Books table and an Authors table. A junction or associative table - these are used to match up primary keys for many-to-many relationships to reduce the amount of redundant data stored. Heres a diagram to explain: Here a single asterisk picks out the primary key, a double asterisk means that column is a foreign key. A book with multiple authors will have multiple rows in the junction table, instead of multiple rows in the books table where a lot more data would have to be repeated. Database normalisation - structuring a database so as to minimise redundant data storage. Dimensional model - a way of structuring a database into fact and dimension tables. The chapter explains: So, for example, a transactional record of an item purchased at a retail store is a fact, containing the timestamp of the purchase, the store number, order number, customer number, and the amount paid. The store the purchase was made at is a dimension of the item purchase fact, and the associated store dimension table would contain additional information about the store, such as its name. You could then query both the fact and the dimension tables to get a summary of purchases by store. The chapter then has a nice section about some of the questions you may want to ask when first being introduced to a data source, before going on to describe the Farmers Market database that will be used over the rest of the book. Heres the ERD: 1.2 Exercises Ex. 1 Question What do you think will happen in the described Books and Authors database depicted in Figure 1.5 if an author changes their name? Which records might be added or updated, and what might be the effect on the results of future queries based on this data? Answer If we wanted to completely overwrite the authors previous name, nothing in the Books table would need to change. The Author ID wouldnt need to change, and so nothing in the junction table would need to change. Only the entry for Author Full Name in the Authors table would need to be altered. In this case database normalisation has made updating the author name straightforward. However I believe the question is getting at the case where an author writes a book under one name, and then changes their name before releasing a new book. We want to keep both names in this database, each associated with the respective books. This could be accomplished by adding a new Author ID and a new row in the Authors table. However this could mislead us for some future queries - e.g. if we wanted to ask the average number of books written by each author, our query might count this as two authors with (say) one book each instead of the same author with two books. We cant have the same Author ID attached to each of the two names - Author ID is our primary key. Perhaps there is some other way to represent in our database that these two names refer to the same person. Ex. 2 Question Think of something in your life that you could track using a database. What entities in this database might have one-to-many relationships with one another? Many-to-many? Answer If I were so inclined, I could keep track of data about my walks and turn this into a database. E.g. what species of birds I see - I think this would be a many-to-many relationship, on each walk I see multiple species of birds and I might see each species on multiple walks. An example of one-to-many might be weather. I.e. it might be rainy on multiple different walks but each walk will only have one type of weather. Although that last part probably does not reflect the reality of being outside in Scotland. "],["select.html", "Chapter 2 The SELECT Statement 2.1 Chapter Notes 2.2 Exercises", " Chapter 2 The SELECT Statement 2.1 Chapter Notes The next few chapters introduce basic SQL syntax. Heres a very simple example: SELECT * FROM farmers_market.product Table 2.1: Displaying records 1 - 5 product_id product_name product_size product_category_id product_qty_type 1 Habanero Peppers - Organic medium 1 lbs 2 Jalapeno Peppers - Organic small 1 lbs 3 Poblano Peppers - Organic large 1 unit 4 Banana Peppers - Jar 8 oz 3 unit 5 Whole Wheat Bread 1.5 lbs 3 unit Weve selected all columns from the table named product, and Ive used R Markdowns knit options to limit the results displayed to the first five rows. We can use SQLs LIMIT clause for the same effect: SELECT * FROM farmers_market.product LIMIT 5 Table 0.1: 5 records product_id product_name product_size product_category_id product_qty_type 1 Habanero Peppers - Organic medium 1 lbs 2 Jalapeno Peppers - Organic small 1 lbs 3 Poblano Peppers - Organic large 1 unit 4 Banana Peppers - Jar 8 oz 3 unit 5 Whole Wheat Bread 1.5 lbs 3 unit Line breaks, tabs and spaces are treated the same by SQL. Usually adding line breaks makes for more legible code. Instead of asking for all columns, we can specify the ones we want in the SELECT clause: SELECT product_id, product_name FROM farmers_market.product LIMIT 5 Table 2.2: 5 records product_id product_name 1 Habanero Peppers - Organic 2 Jalapeno Peppers - Organic 3 Poblano Peppers - Organic 4 Banana Peppers - Jar 5 Whole Wheat Bread The chapter introduces the ORDER BY clause: SELECT product_id, product_name FROM farmers_market.product ORDER BY product_name LIMIT 5 Table 2.3: 5 records product_id product_name 7 Apple Pie 13 Baby Salad Lettuce Mix 12 Baby Salad Lettuce Mix - Bag 4 Banana Peppers - Jar 17 Carrots The default ASC behaviour sorts text alphabetically and numbers from low to high, but we can also use the DESC behaviour: SELECT product_id, product_name FROM farmers_market.product ORDER BY product_name DESC LIMIT 5 Table 2.4: 5 records product_id product_name 5 Whole Wheat Bread 9 Sweet Potatoes 16 Sweet Corn 22 Roma Tomatoes 15 Red Potatoes - Small We can also sort on multiple columns. The code below sorts first on market date and then on vendor ID: SELECT market_date, vendor_id, booth_number FROM farmers_market.vendor_booth_assignments ORDER BY market_date, vendor_id LIMIT 5 Table 2.5: 5 records market_date vendor_id booth_number 2019-04-03 1 2 2019-04-03 3 1 2019-04-03 4 7 2019-04-03 7 11 2019-04-03 8 6 We can also do simple calculations on the columns from within the SELECT clause. The code below contains two calculatios like this. First, the columns quantity and cost_to_customer_per_qty are multiplied together and the AS keyword is used to give the resulting column the alias price. The the function ROUND is used to round the resulting price column to 2 digits after the decimal point. The ROUND function also accepts negative numbers to round digits to the left of the decimal point. SELECT market_date, customer_id, vendor_id, ROUND(quantity * cost_to_customer_per_qty,2) AS price FROM farmers_market.customer_purchases LIMIT 5 Table 2.6: 5 records market_date customer_id vendor_id price 2019-07-03 14 7 6.92 2019-07-03 14 7 15.24 2019-07-03 15 7 10.69 2019-07-03 16 7 14.12 2019-07-03 22 7 4.61 Another common function is the CONCAT function, which can be used inside the SELECT statement to e.g. combine first and last names into a single column like so: CONCAT(customer_first_name,  , customer_last_name) AS customer_name. The UPPER function puts text values in all caps. There is then a section about using the query editor in MySQL workbench to perform some basic checks on your query. I did a little of that but obviously cant display that here. One option that R Markdown allows for though is to assign the result of your query to some R object using the output.var option. Here Ive included output.var=transactions in the SQL chunk options and when I run the query: SELECT market_date, customer_id, vendor_id, ROUND(quantity * cost_to_customer_per_qty, 2) AS price FROM farmers_market.customer_purchases I get a data frame with 4,221 rows, and I can then use standard R functions to check if the query is returning results as expected. E.g. range(transactions$market_date) ## [1] &quot;2019-04-03&quot; &quot;2020-10-10&quot; 2.2 Exercises Ex. 1 Question Write a query that returns everything in the customer table. Answer SELECT * FROM farmers_market.customer Table 2.7: 26 records customer_id customer_first_name customer_last_name customer_zip 1 Jane Connor 22801 2 Manuel Diaz 22821 3 Bob Wilson 22821 4 Deanna Washington 22801 5 Abigail Harris 22801 6 Betty Bullard 22801 7 Jessica Armenta 22821 8 Norma Valenzuela 22821 9 Janet Forbes 22801 10 Russell Edwards 22801 11 Richard Paulson 22801 12 Jack Wise 22821 13 Jeremy Gruber 22821 14 William Lopes 22801 15 Darrell Messina 22801 16 Ada Nieves 22801 17 Carlos Diaz 22802 18 Jeri Mitchell 22802 19 Iva Kienzler 22802 20 Valerie Loftis 22802 21 Duane Sipp 22801 22 George Rai 22801 23 Alvin Laurie 22801 24 Dawn Nale 22801 25 Bonnie Hassan 22801 26 Tracie Goehring 22821 Ex. 2 Question Write a query that displays all of the columns and 10 rows from the customer table, sorted by customer_last_name , then customer_first_name . Answer SELECT * FROM farmers_market.customer ORDER BY customer_last_name, customer_first_name LIMIT 10 Table 2.8: 10 records customer_id customer_first_name customer_last_name customer_zip 7 Jessica Armenta 22821 6 Betty Bullard 22801 1 Jane Connor 22801 17 Carlos Diaz 22802 2 Manuel Diaz 22821 10 Russell Edwards 22801 9 Janet Forbes 22801 26 Tracie Goehring 22821 13 Jeremy Gruber 22821 5 Abigail Harris 22801 Ex. 3 Question Write a query that lists all customer IDs and first names in the customer table, sorted by first_name. Answer SELECT customer_id, customer_first_name FROM farmers_market.customer ORDER BY customer_first_name Table 2.9: 26 records customer_id customer_first_name 5 Abigail 16 Ada 23 Alvin 6 Betty 3 Bob 25 Bonnie 17 Carlos 15 Darrell 24 Dawn 4 Deanna 21 Duane 22 George 19 Iva 12 Jack 1 Jane 9 Janet 13 Jeremy 18 Jeri 7 Jessica 2 Manuel 8 Norma 11 Richard 10 Russell 26 Tracie 20 Valerie 14 William "],["where.html", "Chapter 3 The WHERE Clause 3.1 Chapter Notes 3.2 Exercises", " Chapter 3 The WHERE Clause 3.1 Chapter Notes The chapter introduces the WHERE clause, which filters the results returned by your query. For example, the following code returns rows from the product table where the product_category_id is 1: SELECT product_id, product_name, product_category_id FROM farmers_market.product WHERE product_category_id = 1 LIMIT 5 Table 2.1: 5 records product_id product_name product_category_id 1 Habanero Peppers - Organic 1 2 Jalapeno Peppers - Organic 1 3 Poblano Peppers - Organic 1 9 Sweet Potatoes 1 12 Baby Salad Lettuce Mix - Bag 1 We can use Boolean operators OR, AND, NOT, AND NOT, or OR NOT with the WHERE clause. For example: SELECT market_date, customer_id, vendor_id, product_id, quantity, quantity * cost_to_customer_per_qty AS price FROM farmers_market.customer_purchases WHERE customer_id = 3 OR customer_id = 4 ORDER BY market_date, customer_id, vendor_id, product_id LIMIT 5 Table 0.1: 5 records market_date customer_id vendor_id product_id quantity price 2019-04-03 3 7 4 1 4.0 2019-04-03 4 7 4 1 4.0 2019-04-06 4 8 5 1 6.5 2019-04-10 4 7 4 5 20.0 2019-04-10 4 7 4 3 12.0 We can also use &gt;, &lt;, &gt;=, &lt;=. SELECT market_date, customer_id, vendor_id, product_id, quantity, quantity * cost_to_customer_per_qty AS price FROM farmers_market.customer_purchases WHERE customer_id &gt; 2 AND customer_id &lt;= 4 ORDER BY market_date, customer_id, vendor_id, product_id LIMIT 5 Table 2.2: 5 records market_date customer_id vendor_id product_id quantity price 2019-04-03 3 7 4 1 4.0 2019-04-03 4 7 4 1 4.0 2019-04-06 4 8 5 1 6.5 2019-04-10 4 7 4 5 20.0 2019-04-10 4 7 4 3 12.0 And we can nest operators using parentheses: SELECT product_id, product_name FROM farmers_market.product WHERE product_id = 10 OR (product_id &gt; 3 AND product_id &lt; 8) Table 2.3: 5 records product_id product_name 4 Banana Peppers - Jar 5 Whole Wheat Bread 6 Cut Zinnias Bouquet 7 Apple Pie 10 Eggs We arent confined to filter on a single column, we could easily use the WHERE clause to return e.g. rows where the customer_id is &lt; 5 and the vendor_id is 8 or similar. Other options for filtering include BETWEEN: SELECT * FROM farmers_market.vendor_booth_assignments WHERE vendor_id = 7 AND market_date BETWEEN &#39;2019-04-03&#39; AND &#39;2019-04-16&#39; ORDER BY market_date Table 2.4: 4 records vendor_id booth_number market_date 7 11 2019-04-03 7 11 2019-04-06 7 11 2019-04-10 7 11 2019-04-13 IN: SELECT customer_id, customer_first_name, customer_last_name FROM farmers_market.customer WHERE customer_last_name IN (&#39;Diaz&#39;, &#39;Edwards&#39;, &#39;Wilson&#39;) ORDER BY customer_last_name, customer_first_name Table 2.5: 4 records customer_id customer_first_name customer_last_name 17 Carlos Diaz 2 Manuel Diaz 10 Russell Edwards 3 Bob Wilson LIKE: SELECT customer_id, customer_first_name, customer_last_name FROM farmers_market.customer WHERE customer_first_name LIKE &#39;Jer%&#39; Table 2.6: 2 records customer_id customer_first_name customer_last_name 13 Jeremy Gruber 18 Jeri Mitchell Here the % sign acts as a wildcard so that all first names that start with Jer and have any number (or zero) additional characters will be included. IS NULL / IS NOT NULL - this one is pretty straightforward but note that NULL entries and blank entries are not the same: SELECT * FROM farmers_market.product WHERE product_size IS NULL OR TRIM(product_size) = &#39;&#39; Table 3.1: 2 records product_id product_name product_size product_category_id product_qty_type 14 Red Potatoes NA 1 NA 15 Red Potatoes - Small 1 NA The TRIM function used above removes spaces from the beginning and end of a string, and so can be used to find rows with entries that are blank, or just a space, or any number of spaces. Each of these are different from a NULL entry. The chapter ends with a section on subqueries - queries within queries. In the IN example above, we used a hardcoded list of names, but we could also feed the results of one query into the WHERE criteria of another query: SELECT market_date, customer_id, vendor_id, quantity * cost_to_customer_per_qty price FROM farmers_market.customer_purchases WHERE market_date IN ( SELECT market_date FROM farmers_market.market_date_info WHERE market_rain_flag = 1 ) LIMIT 5 Table 3.2: 5 records market_date customer_id vendor_id price 2019-07-31 3 7 18.4536 2019-07-31 8 7 26.7717 2019-07-31 19 7 25.7931 2019-07-31 22 7 7.4793 2019-09-21 6 7 13.9101 In the query above we use a query on the market_date_info table to return all the dates when it rained, and then query the customer_purchases table to return purchases on those days. 3.2 Exercises Ex. 1 Question Refer to the data in Table 3.1. Write a query that returns all customer purchases of product IDs 4 and 9. Answer Heres Table 3.1: SELECt * FROM table3.1 WHERE PRODUCT_ID = 4 OR PRODUCT_ID = 9 Ex. 2 Question Refer to the data in Table 3.1. Write two queries, one using two conditions with an AND operator, and one using the BETWEEN operator, that will return all customer purchases made from vendors with vendor IDs between 8 and 10 (inclusive). Answer SELECt * FROM table3.1 WHERE VENDOR_ID &gt;= 8 AND VENDOR_ID &lt;= 10 SELECt * FROM table3.1 WHERE VENDOR_ID BETWEEN 8 AND 10 Ex. 3 Question Can you think of two different ways to change the final query in the chapter so it would return purchases from days when it wasnt raining? Answer We could change the criterion on market_rain_flag to 0: SELECT market_date, customer_id, vendor_id, quantity * cost_to_customer_per_qty price FROM farmers_market.customer_purchases WHERE market_date IN ( SELECT market_date FROM farmers_market.market_date_info WHERE market_rain_flag = 0 ) LIMIT 5 Table 3.3: 5 records market_date customer_id vendor_id price 2019-07-03 14 7 6.9201 2019-07-03 14 7 15.2382 2019-07-03 15 7 10.6947 2019-07-03 16 7 14.1198 2019-07-03 22 7 4.6134 Or we could use NOT IN instead of IN: SELECT market_date, customer_id, vendor_id, quantity * cost_to_customer_per_qty price FROM farmers_market.customer_purchases WHERE market_date NOT IN ( SELECT market_date FROM farmers_market.market_date_info WHERE market_rain_flag = 1 ) LIMIT 5 Table 3.4: 5 records market_date customer_id vendor_id price 2019-07-03 14 7 6.9201 2019-07-03 14 7 15.2382 2019-07-03 15 7 10.6947 2019-07-03 16 7 14.1198 2019-07-03 22 7 4.6134 "],["case.html", "Chapter 4 CASE Statements 4.1 Chapter Notes 4.2 Exercises", " Chapter 4 CASE Statements 4.1 Chapter Notes CASE statements are used to create derived columns. Heres a list of vendors and the kind of items they sell: SELECT vendor_id, vendor_name, vendor_type FROM farmers_market.vendor Table 2.1: 9 records vendor_id vendor_name vendor_type 1 Chriss Sustainable Eggs &amp; Meats Eggs &amp; Meats 2 Hernández Salsa &amp; Veggies Fresh Variety: Veggies &amp; More 3 Mountain View Vegetables Fresh Variety: Veggies &amp; More 4 Fields of Corn Fresh Focused 5 Seashell Clay Shop Arts &amp; Jewelry 6 Mothers Garlic &amp; Greens Fresh Variety: Veggies &amp; More 7 Marcos Peppers Fresh Focused 8 Annies Pies Prepared Foods 9 Mediterranean Bakery Prepared Foods We can use a CASE statement to add a new column that specifies whether the vendors sell fresh produce or something else: SELECT vendor_id, vendor_name, vendor_type, CASE WHEN LOWER(vendor_type) LIKE &#39;%fresh%&#39; THEN &#39;Fresh Produce&#39; ELSE &#39;Other&#39; END AS vendor_type_condensed FROM farmers_market.vendor Table 0.1: 9 records vendor_id vendor_name vendor_type vendor_type_condensed 1 Chriss Sustainable Eggs &amp; Meats Eggs &amp; Meats Other 2 Hernández Salsa &amp; Veggies Fresh Variety: Veggies &amp; More Fresh Produce 3 Mountain View Vegetables Fresh Variety: Veggies &amp; More Fresh Produce 4 Fields of Corn Fresh Focused Fresh Produce 5 Seashell Clay Shop Arts &amp; Jewelry Other 6 Mothers Garlic &amp; Greens Fresh Variety: Veggies &amp; More Fresh Produce 7 Marcos Peppers Fresh Focused Fresh Produce 8 Annies Pies Prepared Foods Other 9 Mediterranean Bakery Prepared Foods Other Note the comma after vendor_type - it looks like CASE is included as part of the SELECT clause. Note also the catch-all ELSE command. CASE statements are often used to create binary flag fields: SELECT market_date, CASE WHEN market_day = &#39;Saturday&#39; OR market_day = &#39;Sunday&#39; THEN 1 ELSE 0 END AS weekend_flag FROM farmers_market.market_date_info LIMIT 5 Table 2.2: 5 records market_date weekend_flag 2019-03-02 1 2019-03-09 1 2019-03-13 0 2019-03-16 1 2019-03-20 0 or to bin continuous variables: SELECT market_date, customer_id, vendor_id, ROUND(quantity * cost_to_customer_per_qty, 2) AS price, CASE WHEN quantity * cost_to_customer_per_qty &lt; 5.00 THEN &#39;Under $5&#39; WHEN quantity * cost_to_customer_per_qty &lt; 10.00 THEN &#39;$5-$9.99&#39; WHEN quantity * cost_to_customer_per_qty &lt; 20.00 THEN &#39;$10-$19.99&#39; WHEN quantity * cost_to_customer_per_qty&gt;= 20.00 THEN &#39;$20 and Up&#39; END AS price_bin FROM farmers_market.customer_purchases LIMIT 10 Table 2.3: 10 records market_date customer_id vendor_id price price_bin 2019-07-03 14 7 6.92 $5-$9.99 2019-07-03 14 7 15.24 $10-$19.99 2019-07-03 15 7 10.69 $10-$19.99 2019-07-03 16 7 14.12 $10-$19.99 2019-07-03 22 7 4.61 Under $5 2019-07-06 4 7 1.89 Under $5 2019-07-06 12 7 25.16 $20 and Up 2019-07-06 14 7 21.25 $20 and Up 2019-07-06 23 7 10.42 $10-$19.99 2019-07-06 23 7 17.89 $10-$19.99 4.2 Exercises Ex. 1 Question Products can be sold by the individual unit or by bulk measures like lbs. or oz. Write a query that outputs the product_id and product_name columns from the product table, and add a column called prod_qty_type_condensed that displays the word unit if the product_qty_type is unit, and otherwise displays the word bulk. Answer SELECT product_id, product_name, CASE WHEN LOWER(product_qty_type) LIKE &#39;%unit%&#39; THEN &#39;unit&#39; ELSE &#39;bulk&#39; END AS prod_qty_type_condensed FROM farmers_market.product Table 2.4: 23 records product_id product_name prod_qty_type_condensed 1 Habanero Peppers - Organic bulk 2 Jalapeno Peppers - Organic bulk 3 Poblano Peppers - Organic unit 4 Banana Peppers - Jar unit 5 Whole Wheat Bread unit 6 Cut Zinnias Bouquet unit 7 Apple Pie unit 8 Cherry Pie unit 9 Sweet Potatoes bulk 10 Eggs unit 11 Pork Chops bulk 12 Baby Salad Lettuce Mix - Bag unit 13 Baby Salad Lettuce Mix bulk 14 Red Potatoes bulk 15 Red Potatoes - Small bulk 16 Sweet Corn unit 17 Carrots bulk 18 Carrots - Organic unit 19 Farmers Market Resuable Shopping Bag unit 20 Homemade Beeswax Candles unit 21 Organic Cherry Tomatoes unit 22 Roma Tomatoes bulk 23 Maple Syrup - Jar unit Ex. 2 Question We want to flag all of the different types of pepper products that are sold at the market. Add a column to the previous query called pepper_flag that outputs a 1 if the product_name contains the word pepper (regardless of capitalization), and otherwise outputs 0. Answer SELECT product_id, product_name, CASE WHEN LOWER(product_qty_type) LIKE &#39;%unit%&#39; THEN &#39;unit&#39; ELSE &#39;bulk&#39; END AS prod_qty_type_condensed, CASE WHEN LOWER(product_name) LIKE &#39;%pepper%&#39; THEN 1 ELSE 0 END AS pepper_flag FROM farmers_market.product Table 2.5: 23 records product_id product_name prod_qty_type_condensed pepper_flag 1 Habanero Peppers - Organic bulk 1 2 Jalapeno Peppers - Organic bulk 1 3 Poblano Peppers - Organic unit 1 4 Banana Peppers - Jar unit 1 5 Whole Wheat Bread unit 0 6 Cut Zinnias Bouquet unit 0 7 Apple Pie unit 0 8 Cherry Pie unit 0 9 Sweet Potatoes bulk 0 10 Eggs unit 0 11 Pork Chops bulk 0 12 Baby Salad Lettuce Mix - Bag unit 0 13 Baby Salad Lettuce Mix bulk 0 14 Red Potatoes bulk 0 15 Red Potatoes - Small bulk 0 16 Sweet Corn unit 0 17 Carrots bulk 0 18 Carrots - Organic unit 0 19 Farmers Market Resuable Shopping Bag unit 0 20 Homemade Beeswax Candles unit 0 21 Organic Cherry Tomatoes unit 0 22 Roma Tomatoes bulk 0 23 Maple Syrup - Jar unit 0 Ex. 3 Question Can you think of a situation when a pepper product might not get flagged as a pepper product using the code from the previous exercise? Answer The product could just be called Jalapenos - Organic or similar, anything without the word pepper in it wont be flagged. "],["sql_joins.html", "Chapter 5 SQL JOINs 5.1 Chapter Notes 5.2 Exercises", " Chapter 5 SQL JOINs 5.1 Chapter Notes JOINs are used to pull data from across multiple related tables. Lets say we want to list the name of each product along with its category. These are stored in different tables: SELECT * FROM product LEFT JOIN product_category ON product.product_category_id = product_category.product_category_id LIMIT 5 Table 2.1: 5 records product_id product_name product_size product_category_id product_qty_type product_category_id..6 product_category_name 1 Habanero Peppers - Organic medium 1 lbs 1 Fresh Fruits &amp; Vegetables 2 Jalapeno Peppers - Organic small 1 lbs 1 Fresh Fruits &amp; Vegetables 3 Poblano Peppers - Organic large 1 unit 1 Fresh Fruits &amp; Vegetables 4 Banana Peppers - Jar 8 oz 3 unit 3 Packaged Prepared Food 5 Whole Wheat Bread 1.5 lbs 3 unit 3 Packaged Prepared Food The code above stitches together the product table and the product_category table, used the product_category_id column in each. This is a LEFT JOIN, which means: All rows in the product table are kept, even if there are no matches in the product_category table Rows in the product_category table for IDs that dont appear in the product table are dropped. If there are no products in the product table with product_category_id 7 (Non-Edible Products), then that row of the product_category table will not appear in the results. Also, the code above is the first time Ive seen the code not specify the database. I.e. it refers to product instead of farmers_market.product. Im not exactly sure about when this can be left out, but its not specific to JOINs at all - the farmers_market part can be removed from the queries in previous chapters and the code will still run. Note that product_category_id appears in the results above twice - one from each table (although I believe R is adding ..6 to the second one, since it doesnt like data frames with multiple columns with the same name). We could prevent this by specifying which columns to include, or by creating an alias for the column names that specifies which table each ID column came from: SELECT product.product_id, product.product_name, product.product_category_id AS product_prod_cat_id, product_category.product_category_id AS category_prod_cat_id, product_category.product_category_name FROM product LEFT JOIN product_category ON product.product_category_id = product_category.product_category_id LIMIT 5 Table 0.1: 5 records product_id product_name product_prod_cat_id category_prod_cat_id product_category_name 1 Habanero Peppers - Organic 1 1 Fresh Fruits &amp; Vegetables 2 Jalapeno Peppers - Organic 1 1 Fresh Fruits &amp; Vegetables 3 Poblano Peppers - Organic 1 1 Fresh Fruits &amp; Vegetables 4 Banana Peppers - Jar 3 3 Packaged Prepared Food 5 Whole Wheat Bread 3 3 Packaged Prepared Food The chapter also demonstrates aliasing that is used to shorten the table names in the rest of the query for convenience. It doesnt affect results. In the code that follows the product table is aliased as p and the product_category table is aliased as pc. SELECT p.product_id, p.product_name, pc.product_category_id, pc.product_category_name FROM product AS p LEFT JOIN product_category AS pc ON p.product_category_id = pc.product_category_id ORDER BY pc.product_category_name, p.product_name LIMIT 5 Table 2.2: 5 records product_id product_name product_category_id product_category_name 10 Eggs 6 Eggs &amp; Meat (Fresh or Frozen) 11 Pork Chops 6 Eggs &amp; Meat (Fresh or Frozen) 13 Baby Salad Lettuce Mix 1 Fresh Fruits &amp; Vegetables 12 Baby Salad Lettuce Mix - Bag 1 Fresh Fruits &amp; Vegetables 17 Carrots 1 Fresh Fruits &amp; Vegetables You can see the shortened table names used in the SELECT clause, and when specifying the joining columns and ordering. In general with aliasing, the AS keyword is optional. The code product AS p and product p will do the same thing. RIGHT JOINs work analogously: SELECT p.product_id, p.product_name, pc.product_category_id, pc.product_category_name FROM product AS p RIGHT JOIN product_category AS pc ON p.product_category_id = pc.product_category_id ORDER BY p.product_name LIMIT 5 Table 2.3: 5 records product_id product_name product_category_id product_category_name NA NA 4 Freshly Prepared Food 7 Apple Pie 3 Packaged Prepared Food 13 Baby Salad Lettuce Mix 1 Fresh Fruits &amp; Vegetables 12 Baby Salad Lettuce Mix - Bag 1 Fresh Fruits &amp; Vegetables 4 Banana Peppers - Jar 3 Packaged Prepared Food A couple points to note about these results. All rows from the product_category table are included, even when no product is assigned to that category. In the table above, no products are in category 4 (Freshly Prepared Food), but it still appears in the results. Rows from the product_category table can be included multiple times. The results above (when not using LIMIT) will have 24 rows, one for each of the 23 products plus 1 for category 4. If there could be multiple product categories for each product, then they would both appear in the left join performed above, so the results would have more than 23 rows. INNER JOINs keep only rows where the product_category_id appears in both tables: SELECT p.product_id, p.product_name, pc.product_category_id, pc.product_category_name FROM product AS p INNER JOIN product_category AS pc ON p.product_category_id = pc.product_category_id ORDER BY p.product_name LIMIT 5 Table 2.4: 5 records product_id product_name product_category_id product_category_name 7 Apple Pie 3 Packaged Prepared Food 13 Baby Salad Lettuce Mix 1 Fresh Fruits &amp; Vegetables 12 Baby Salad Lettuce Mix - Bag 1 Fresh Fruits &amp; Vegetables 4 Banana Peppers - Jar 3 Packaged Prepared Food 17 Carrots 1 Fresh Fruits &amp; Vegetables In this case the results are the same as the left join, since each product has an assigned product_category_id. Joins can be performed multiple times, with the second join effectively acting to join together the results of the first join with another table. 5.2 Exercises Ex. 1 Question Write a query that INNER JOINs the vendor table to the vendor_booth_assignments table on the vendor_id field they both have in common, and sorts the result by vendor_name , then market_date. Answer SELECT * FROM vendor AS v INNER JOIN vendor_booth_assignments AS vba ON v.vendor_id = vba.vendor_id ORDER BY vendor_name, market_date LIMIT 5 Table 2.5: 5 records vendor_id vendor_name vendor_type vendor_owner_first_name vendor_owner_last_name vendor_id..6 booth_number market_date 8 Annies Pies Prepared Foods Annie Aquinas 8 6 2019-04-03 8 Annies Pies Prepared Foods Annie Aquinas 8 6 2019-04-06 8 Annies Pies Prepared Foods Annie Aquinas 8 6 2019-04-10 8 Annies Pies Prepared Foods Annie Aquinas 8 6 2019-04-13 8 Annies Pies Prepared Foods Annie Aquinas 8 6 2019-04-17 Ex. 2 Question Is it possible to write a query that produces an output identical to the output of the following query, but using a LEFT JOIN instead of a RIGHT JOIN? SELECT * FROM customer AS c RIGHT JOIN customer_purchases AS cp ON c.customer_id = cp.customer_id LIMIT 10 Table 2.6: 10 records customer_id customer_first_name customer_last_name customer_zip product_id vendor_id market_date customer_id..8 quantity cost_to_customer_per_qty transaction_time 14 William Lopes 22801 1 7 2019-07-03 14 0.99 6.99 17:32:00 14 William Lopes 22801 1 7 2019-07-03 14 2.18 6.99 18:23:00 15 Darrell Messina 22801 1 7 2019-07-03 15 1.53 6.99 18:41:00 16 Ada Nieves 22801 1 7 2019-07-03 16 2.02 6.99 18:18:00 22 George Rai 22801 1 7 2019-07-03 22 0.66 6.99 17:34:00 4 Deanna Washington 22801 1 7 2019-07-06 4 0.27 6.99 12:20:00 12 Jack Wise 22821 1 7 2019-07-06 12 3.60 6.99 09:33:00 14 William Lopes 22801 1 7 2019-07-06 14 3.04 6.99 13:05:00 23 Alvin Laurie 22801 1 7 2019-07-06 23 1.49 6.99 12:26:00 23 Alvin Laurie 22801 1 7 2019-07-06 23 2.56 6.99 12:46:00 Answer Probably theres a less clumsy way of getting the columns in the right order, but this works: SELECT c.customer_id, c.customer_first_name, c.customer_last_name, c.customer_zip, cp.product_id, cp.vendor_id, cp.market_date, cp.customer_id, cp.quantity, cp.cost_to_customer_per_qty, cp.transaction_time FROM customer_purchases AS cp LEFT JOIN customer AS c ON cp.customer_id = c.customer_id LIMIT 10 Table 3.1: 10 records customer_id customer_first_name customer_last_name customer_zip product_id vendor_id market_date customer_id..8 quantity cost_to_customer_per_qty transaction_time 14 William Lopes 22801 1 7 2019-07-03 14 0.99 6.99 17:32:00 14 William Lopes 22801 1 7 2019-07-03 14 2.18 6.99 18:23:00 15 Darrell Messina 22801 1 7 2019-07-03 15 1.53 6.99 18:41:00 16 Ada Nieves 22801 1 7 2019-07-03 16 2.02 6.99 18:18:00 22 George Rai 22801 1 7 2019-07-03 22 0.66 6.99 17:34:00 4 Deanna Washington 22801 1 7 2019-07-06 4 0.27 6.99 12:20:00 12 Jack Wise 22821 1 7 2019-07-06 12 3.60 6.99 09:33:00 14 William Lopes 22801 1 7 2019-07-06 14 3.04 6.99 13:05:00 23 Alvin Laurie 22801 1 7 2019-07-06 23 1.49 6.99 12:26:00 23 Alvin Laurie 22801 1 7 2019-07-06 23 2.56 6.99 12:46:00 Ex. 3 Question At the beginning of this chapter, the analytical question When is each type of fresh fruit or vegetable in season, locally? was asked, and it was explained that the answer requires data from the product_category table, the product table, and the vendor_inventory table. What type of JOINs do you expect would be needed to combine these three tables in order to be able to answer this question? Answer I believe this code would get you most of the way there. You just need a way of summarising the range of market_date for each product, which it looks like we might learn in the next chapter. SELECT p.product_id, p.product_name, pc.product_category_name, vi.market_date FROM product AS p LEFT JOIN product_category AS pc ON p.product_category_id = pc.product_category_id LEFT JOIN vendor_inventory AS vi ON p.product_id = vi.product_id WHERE LOWER(product_category_name) LIKE &quot;%fruit%&quot; ORDER BY product_name, market_date LIMIT 10 Table 3.2: 10 records product_id product_name product_category_name market_date 13 Baby Salad Lettuce Mix Fresh Fruits &amp; Vegetables NA 12 Baby Salad Lettuce Mix - Bag Fresh Fruits &amp; Vegetables NA 17 Carrots Fresh Fruits &amp; Vegetables NA 18 Carrots - Organic Fresh Fruits &amp; Vegetables NA 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-03 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-06 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-10 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-13 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-17 1 Habanero Peppers - Organic Fresh Fruits &amp; Vegetables 2019-07-20 Although we wont be able to get an answer if there is nothing recorded in the vendor_inventory table for that item, so perhaps wed be just as well using an INNER JOIN for that second join. However it may be useful to know when the information we want isnt available, rather than just silently dropping the NULL results. "],["aggregating.html", "Chapter 6 Aggregating Results for Analysis 6.1 Chapter Notes 6.2 Exercises Further Reading", " Chapter 6 Aggregating Results for Analysis 6.1 Chapter Notes 6.2 Exercises Ex. 1 Question Answer Further Reading "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
